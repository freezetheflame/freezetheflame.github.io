{"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2023/08/01/hello-world/"},{"title":"intro","text":"Lecture 1首先教授给我们概述了已有的知识框架并且大概描述了之后需要学习的内容 Overview Divide and Conquer - FFT, Randomized algorithms Optimization - greedy and dynamic programming Network Flow Intractibility (and dealing with it) Linear programming Sublinear algorithms, approximation algorithms Advanced topics NP问题： P：所有问题多项式时间可解 NP：在多项式时间内“可验证”的问题。 NPC：存在这样一个NP问题，所有的NP问题都可以约化成它。 NP-complete：NP范围且和NP内任何一个问题一样难的问题 Interval Scheduling这一题的大意就是要安排一个最多，但是时间互不矛盾的时间表。 要解决这么一个题目，首先明确采用贪心的方式解决 需要设计一个求解局部最优且不影响后效的贪心策略（贪心算法的无后效性） Greedy Interval Scheduling Use a simple rule to select a request i. Reject all requests incompatible with i. Repeat until all requests are processed. 重点在于这个“rule”的选择","link":"/2023/07/31/intro/"},{"title":"java notes","text":"JAVA learning from CS61B[TOC] IntroWhat is CS61B mainly about Writing code that runs efficiently. good algorithm good data structures Writing code efficiently. designing,building, testing, and debugging large programs. using tools like IntelliJ , JUnit , and various command line tools Java (not the focus of the course!) Compilation Class DOG: not all classes are main class To run a class, we must define a main method Defining a Typical Class (Terminology) 1234567891011121314151617181920212223242526272829public class Dog {public int weightInPounds; // instance variable and can have many as it havepublic Dog(int startingWeight) { //ConstructorweightInPounds = startingWeight;} public void makeNoise() { //Non static methodif (weightInPounds &lt; 10) { System.out.println(&quot;yipyipyip!&quot;); } else if (weightInPounds &lt; 30) { System.out.println(&quot;bark. bark.&quot;); } else { System.out.println(&quot;woof!&quot;); } }}//roughly speaking: if the method needs to use “my instance variables”, the method must be non-static.public class DogLauncher {public static void main(String[] args) { Dog smallDog; new Dog(20); smallDog = new Dog(5); Dog hugeDog = new Dog(150); smallDog.makeNoise(); hugeDog.makeNoise();}} Arrays of Objects To create an array of objects: First use the new keyword to create the array. Then use new again for each object that you want to put in the array. testingAd Hoc Testing vs. JUnit New Syntax #1: org.junit.Assert.assertEquals(expected, actual); Tests that expected equals actual. If not, program terminates with verbose message. New Syntax #2 (just trust me): Annotate each test with @org.junit.Test. Change all test methods to non-static. Use a JUnit runner to run all tests and tabulate results. IntelliJ provides a default runner/renderer. OK to delete main. There are ways to run JUnit tests from command line. Not taught in our class. Rendered output is easier to read, no need to manually invoke tests! New Syntax #3: To avoid this we’ll start every test file with:import org.junit.Test;import static org.junit.Assert.*;This will magically eliminate the need to type ‘org.junit’ or ‘org.junit.Assert’ (more after the midterm on what these imports really mean). tip: sort:Without changing the signature of public static void sort(String[] a), how can we use recursion? What might the recursive call look like? 12345/** Destructively sorts x starting at index k */public static void sort(String[] x, int k) { ... sort(x, k + 1);} Steps to developing according to TDD: Identify a new feature. Write a unit test for that feature. Run the test. It should fail. (RED) Write code that passes test. (GREEN) Implementation is certifiably good! Optional: Refactor code to make it faster, cleaner, etc. JUnit makes testing easy. You should write tests.But not too many.Only when they might be useful! Write tests first when it feels appropriate [I do this a lot].Lab 3, Project 1B, and Project 2 will give you practice!Most of the class won’t require writing lots of tests (to save you time). Sample Runner Pseudocode12345678910List&lt;Method&gt; L = getMethodsWithAnnotation(TestSort.class, org.junit.Test);int numTests = L.size();int numPassed = 0;for (Method m : L) { result r = m.execute(); if (r.passed == true) { numPassed += 1; } if (r.passed == false) { System.out.println(r.message); }}System.out.println(numPassed + “/” + numTests + “ passed!”); Primitive Types and Data structuresDeclaring a variable:When you declare a variable of a certain type in Java: Your computer sets aside exactly enough bits to hold a thing of that type. Example: Declaring an int sets aside a “box” of 32 bits. Example: Declaring a double sets aside a box of 64 bits. Java creates an internal table that maps each variable name to a location. Java does NOT write anything into the reserved boxes. For safety, Java will not let access a variable that is uninitialized. The Golden Rule of Equals (GRoE) Given variables y and x:y = x copies all the bits from x into y. Reference Types Declaring a class:When we instantiate an Object (e.g. Dog, Walrus, Planet): Java first allocates a box of bits for each instance variable of the class and fills them with a default value (e.g. 0, null). The constructor then usually fills every such box with some other value. Reference Types Obey the Golden Rule of Equals Just as with primitive types, the equals sign copies the bits. In terms of our visual metaphor, we “copy” the arrow by making the arrow in the b box point at the same instance as a. Declaration and Instantiation of ArraysArrays are also Objects. As we’ve seen, objects are (usually) instantiated using the new keyword. 12int[] x = new int[]{0, 1, 2, 95, 4};Planet p = new Planet(0, 0, 0, 0, 0, “blah.png”); Note: Instantiated objects can be lost!If we were to reassign a to something else, we’d never be able to get the original Object back! IntListwe need the following member variables and methods 12345678910111213141516public class IntList { public int first; public IntList rest; public IntList(int f, IntList r) { first = f; rest = r; } /** Return the size of this IntList. */ public int size() { if (rest == null) { return 1; } return 1 + this.rest.size(); ... } Improvements on IntList and Data safetyWhile functional, **“naked” **linked lists like the one above are hard to use. Users of this class are probably going to need to know references very well, and be able to think recursively. Let’s make our users’ lives easier. Step I:Rebranding and Culling12345678910public class IntNode { public int item; public IntNode next; public IntNode(int i, IntNode n) { item = i; next = n; }}// we will reintroduce functionality in the next part Step II: Bureaucracy12345678910public class IntNode { public int item; public IntNode next; public IntNode(int i, IntNode n) { item = i; next = n; }} 1234567public class SLList{ public IntNode first; public SLList(int x) { first = new IntNode(x, null); } //...} While functional, “naked” linked lists like the IntList class are hard to use. Users of IntList are need to know Java references well, and be able to think recursively. SLList is much simpler to use. Simply use the provided methods. Why not just add an addFirst method to the IntList class? Turns out there is no efficient way to do this. See exercises in lectureCode repository. Step III: Access ControlWe can prevent programmers from making such mistakes with the private keyword. Hide implementation details from users of your class. Less for user of class to understand. Safe for you to change private methods (implementation). Car analogy: Public: Pedals, Steering Wheel Private: Fuel line, Rotary valve Step IV: Nested ClassesNested Classes are useful when a class doesn’t stand on its own and is obviously subordinate to another class. Make the nested class private if other classes should never use the nested class.In my opinion, probably makes sense to make IntNode a nested private class. Hard to imagine other classes having a need to manipulate IntNodes. Static Nested Classes If the class don’t need to call any variables outside , you can make it static Static classes cannot access outer class’s instance variables or methods.Results in a minor savings of memory. See book for more details / exercise. addLast() and size()Create a private recursive helper method. Have the public method call the private recursive helper method. 1234567891011121314public class SLList { private int size(IntNode p) { if (p.next == null) { return 1; } return 1 + size(p.next); } public int size() { return size(first); }} Step V: Fast size()Solution: Maintain a special size variable that caches the size of the list.Caching: putting aside data to speed up retrieval. TANSTAAFL: There ain’t no such thing as a free lunch.But spreading the work over each add call is a net win in almost any circumstance. Step VI: Representing the Empty ListWhen the List is empty, we may find error when add last. So one solution is to add a judgement when addLast , though making the whole function look worse. So we come up with another idea： Sentinel Nodes Notes: I’ve renamed first to be sentinel. sentinel is never null, always points to sentinel node. Sentinel node’s item needs to be some integer, but doesn’t matter what value we pick. Had to fix constructors and methods to be compatible with sentinel nodes. Methods Non-Obvious Improvements addFirst(int x) Rebranding: IntList → IntNode getFirst Bureaucracy: SLList size Access Control: public → private addLast(int x) Nested Class: Bringing IntNode into SLList Caching: Saving size as an int Generalizing: Adding a sentinel node to allow representation of the empty list. DLList and Other TrialsStep VII: Modify addLastOn first thought, we tend to only add a .last, so w e can get the last fast , but then it becomes hard to remove. We added .last. What other changes might we make so that remove is also fast?Add backwards links from every node.This yields a “doubly linked list” or DLList, as opposed to our earlier “singly linked list” or SLList. Step VIII: fancier sentinel nodesWhile fast, adding .last and .prev introduces lots of special cases.To avoid these, either: Add an additional sentBack sentinel at the end of the list. Make your linked list circular (highly recommended for project 1), with a single sentinel in the middle. Generic(泛型) ListWe might notice that our list only support Integers while we need to rewrite the whole class while we need other data types. We’ll spend a lot more time with generics later, but here are the rules of thumb you’ll need for project 1: In the .java file implementing your data structure, specify your “generic type” only once at the very top of the file. In .java files that use your data structure, specify desired type once:Write out desired type during declaration. Use the empty diamond operator &lt;&gt; during instantiation.When declaring or instantiating your data structure, use the reference type. int: Integer double: Double char: Character boolean: Boolean long: Longetc. DLList&lt;**Double**&gt; s1 = new DLList&lt;&gt;(5.3);double x = 9.3 + 15.2;s1.insertFront(x); ArraysArrays consist of: ​ A fixed integer length (cannot change!)​ A sequence of N memory boxes where N=length, such that:​ All of the boxes hold the same type of value (and have same # of bits).​ The boxes are numbered 0 through length-1. Like instances of classes: You get one reference when its created. If you reassign all variables containing that reference, you can never get the array back. Unlike classes: ​ Do not have methods. Arrays and Classes can both be used to organize a bunch of memory boxes. Array boxes are accessed using [] notation. Class boxes are accessed using dot notation. Array boxes must all be of the same type. Class boxes may be of different types. Both have a fixed number of boxes. Naive AList1234567891011121314151617181920212223242526public class AList { private int[] items; private int size; public AList() { items = new int[100]; size = 0; } public void addLast(int x) { items[size] = x; size += 1; } public int getLast() { return items[size - 1]; } public int get(int i) { return items[i]; } public int size() { return size; }} So how to remove Last? When we removeLast(), which memory boxes need to change? To what?- ​ User’s mental model: {5, 3, 1, 7, 22, -1} → {5, 3, 1, 7, 22} ​ 1234567public int removeLast() { int returnItem = items[size - 1]; items[size - 1] = 0;//not necessary size -= 1; return returnItem;} Resizing ArrayWhen the array gets too full, e.g. addLast(11), just make a new array: int[] a = new int[size+1]; the improving should be all-around and considering its influence works 12345678910public void addLast(int x) { if (size == items.length) { int[] a = new int[size + 1]; System.arraycopy(items, 0, a, 0, size); items = a; } items[size] = x; size += 1;} 1234567891011121314private void resize(int capacity) { int[] a = new int[capacity]; System.arraycopy(items, 0, a, 0, size); items = a;} public void addLast(int x) { if (size == items.length) { resize(size + 1); } items[size] = x; size += 1;} much better but its to slow and occupy to many memory in total Geometric resizing is much faster: Just how much better will have to wait. like this: 12345678public void addLast(int x) { if (size == items.length) { resize(size * RFACTOR); } items[size] = x; size += 1;} An AList should not only be efficient in time, but also efficient in space. Define the “usage ratio” R = size / items.length; Typical solution: Half array size when R &lt; 0.25. More details in a few weeks. Generic Alists123456789101112131415161718192021public class AList&lt;Glorp&gt; { private Glorp[] items; private int size; public AList() { items = (Glorp []) new Object[8]; size = 0; } private void resize(int cap) { Glorp[] a = (Glorp []) new Object[cap]; System.arraycopy(items, 0, a, 0, size); items = a; } public Glorp get(int i) { return items[i]; }... null out unnecessary items Unlike integer based ALists, we actually want to null out deleted items. Java only destroys unwanted objects when the last reference has been lost. Keeping references to unneeded objects is sometimes called loitering. Save memory. Don’t loiter. Obscurantism in JavaWe talk of “layers of abstraction” often in computer science.Related concept: obscurantism. The user of a class does not and should not know how it works.The Java language allows you to enforce this with ideas like private!A good programmer obscures details from themselves, even within a class.Example: addFirst and resize should be written totally independently. You should not be thinking about the details of one method while writing the other. Simply trust that the other works.Breaking programming tasks down into small pieces (especially functions) helps with this greatly!Through judicious use of testing, we can build confidence in these small pieces, as we’ll see in the next lecture. Inheritance, Implements &amp; InterfaceFirstly, let’s talk about override and override, Overload(重写) and Override(重写)In Java, both override and overload are used to define a new behavior for a method. However, they have different meanings and use cases. Override:When a subclass provides its own implementation for a method that is already present in its superclass, it is called method overriding. The new implementation of the methOverrideod in the subclass is said to override the implementation in the superclass. The signature of the overridden method must be the same as the method in the superclass, including the method name, return type, and parameter list. Example: 123456789101112class Animal { public void makeSound() { System.out.println(&quot;Some animal sound&quot;); }}class Dog extends Animal { @Override public void makeSound() { System.out.println(&quot;Bark&quot;); }} In the above example, the Dog class overrides the makeSound() method of the Animal class to provide its own implementation. Overload:When a class has multiple methods with the same name but different parameters, it is called method overloading. The methods must have the same name but different parameter lists. The return type of the method can be different, but it is not considered when overloading a method. Example: 123456789class Calculator { public int add(int a, int b) { return a + b; } public int add(int a, int b, int c) { return a + b + c; }} In the above example, the Calculator class has two methods with the same name add(), but with different parameter lists. This is an example of method overloading. n 61b, we’ll always mark every overriding method with the @Override annotation. Example: Mark AList.java’s overriding methods with @Override. The only effect of this tag is that the code won’t compile if it is not actually an overriding method. In Java, inheritance and implements are two essential object-oriented programming (OOP) concepts that allow you to create new classes based on existing ones. They promote reuse of code and help you design a more organized and maintainable application. InheritanceInheritance is a mechanism that enables one class to inherit properties (fields) and methods from another class. The class that is being inherited is called the superclass or parent class, and the class that inherits the superclass is called the subclass or derived class. In Java, you use the extends keyword to establish an inheritance relationship between two classes. Syntax: 123class Subclass extends Superclass { // subclass fields and methods} When a subclass inherits a superclass, it has access to: All public and protected fields of the superclass All public and protected methods of the superclass The subclass can also add new fields and methods or override existing methods. However, it cannot inherit the superclass’s private fields and methods directly. Example: 12345678910111213141516171819202122232425262728293031// Superclassclass Animal { protected String name; public Animal(String name) { this.name = name; } public void makeSound() { System.out.println(&quot;The animal makes a sound&quot;); }}// Subclassclass Dog extends Animal { public Dog(String name) { super(name); // call the superclass constructor } @Override public void makeSound() { System.out.println(&quot;The dog barks&quot;); }}public class Main { public static void main(String[] args) { Dog dog = new Dog(&quot;Buddy&quot;); dog.makeSound(); // Output: The dog barks }} ImplementsJava does not support multiple inheritance among classes, but it does allow a class to implement multiple interfaces. An interface is a collection of abstract methods (methods without a body) that can be implemented by any class. To implement an interface, a class must use the implements keyword and provide a body for all the abstract methods declared in the interface. A class can implement multiple interfaces by separating them with a comma. Syntax: 1234567interface InterfaceName { // abstract methods}class ClassName implements InterfaceName { // provide implementation for abstract methods} Example: 12345678910111213141516171819202122232425// Interfaceinterface Drawable { void draw();}// Class implementing the interfaceclass Circle implements Drawable { private double radius; public Circle(double radius) { this.radius = radius; } @Override public void draw() { System.out.println(&quot;Drawing a circle with radius: &quot; + radius); }}public class Main { public static void main(String[] args) { Circle circle = new Circle(5.0); circle.draw(); // Output: Drawing a circle with radius: 5.0 }} In this example, the Circle class implements the Drawable interface and provides an implementation for the draw method. In summary, inheritance in Java allows you to create new classes by extending existing ones, while the implements keyword enables a class to implement one or more interfaces. Both concepts promote code reusability and help you design more organized and maintainable applications. InterfaceIn Java, an interface is a collection of abstract methods and constants, which are defined without an implementation. An interface can be thought of as a contract or a blueprint for a class to implement. It specifies a set of methods and properties that a class must implement in order to be considered an implementation of that interface. An interface can be declared using the interface keyword, followed by the name of the interface and its members. For example: 12345public interface MyInterface { void method1(); void method2(); int CONSTANT = 10;} In this example, MyInterface declares two abstract methods method1() and method2(), and a constant CONSTANT. Any class that implements MyInterface must provide an implementation of these two methods, and can access the constant CONSTANT. To implement an interface in a class, the implements keyword can be used. For example: 12345678public class MyClass implements MyInterface { public void method1() { // implementation of method1 } public void method2() { // implementation of method2 }} In this example, MyClass implements MyInterface and provides an implementation for the method1() and method2() methods. Once a class implements an interface, it must provide an implementation for all of the abstract methods defined in the interface. One of the key benefits of interfaces is that they allow for polymorphism. This means that an object of a class that implements an interface can be treated as an instance of that interface. For example: 12MyInterface obj = new MyClass();obj.method1(); In this example, obj is an instance of MyClass, but it is treated as an instance of MyInterface. This allows for greater flexibility in designing code, as different implementations of an interface can be used interchangeably. In addition to abstract methods and constants, an interface can also contain default methods and static methods, which provide a default implementation and can be called without an instance of the interface, respectively. Default methods were introduced in Java 8, and static methods in Java 8 and later versions. So in java , an interface give lots of abstract methods and constants , while needing a class to implement them Extends, Casting, higher order functionsIn Java, the extends keyword is used to create a subclass that inherits properties and methods from a superclass. The subclass can access all the non-private members (methods and variables) of the superclass, and it can also override inherited methods or define new methods. For example, let’s say we have a Vehicle class with properties like make, model, and year. We can create a Car class that extends Vehicle and adds properties like numDoors and driveType. The Car class can also inherit and override methods from Vehicle. Here’s an example code snippet: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public class Vehicle { private String make; private String model; private int year; // Constructor public Vehicle(String make, String model, int year) { this.make = make; this.model = model; this.year = year; } // Getter methods public String getMake() { return make; } public String getModel() { return model; } public int getYear() { return year; } // Other methods public void startEngine() { System.out.println(&quot;Starting engine...&quot;); }}public class Car extends Vehicle { private int numDoors; private String driveType; // Constructor public Car(String make, String model, int year, int numDoors, String driveType) { super(make, model, year); this.numDoors = numDoors; this.driveType = driveType; } // Getter methods public int getNumDoors() { return numDoors; } public String getDriveType() { return driveType; } // Override inherited method @Override public void startEngine() { System.out.println(&quot;Starting car engine...&quot;); } // New method public void drift() { System.out.println(&quot;Drifting...&quot;); }} In this example, Car is a subclass of Vehicle and inherits the properties make, model, and year. It also adds two new properties, numDoors and driveType. The Car class overrides the startEngine() method from Vehicle to provide its own implementation, and it also adds a new method drift(). In Java, the super keyword is used to refer to the superclass of a subclass. It can be used to call the constructor, methods, and properties of the superclass from the subclass. Tips: Any subclasses construct must include the superclass constructerso if you want to make a new constructor , be sure to use the superclass constructor first In Java, all objects inherit certain default methods from the Object class. These default methods are: equals(Object obj): This method is used to compare two objects and check if they are equal. It returns a boolean value: true if the objects are equal, and false otherwise. hashCode(): This method returns an integer value that represents the hash code of the object. The hash code is used to identify the object and is used in hash-based data structures such as HashMap. toString(): This method returns a string representation of the object. By default, this method returns the class name followed by the object’s hash code. getClass(): This method returns the class object of the current object. finalize(): This method is called by the garbage collector before an object is destroyed. By default, this method does nothing, but it can be overridden by a subclass to perform cleanup operations. It’s worth noting that these methods can be overridden by subclasses to provide their own implementation. In addition, the Object class also provides other methods such as wait(), notify(), and notifyAll() that are used for thread synchronization, but these methods are not considered default methods as they are not inherited by all objects. Encapsulation Design for change. D. Parnas Here’s an example of how encapsulation can make code more flexible: Suppose we have a BankAccount class that represents a bank account. The BankAccount class has a balance field that represents the current balance of the account, and it has a deposit method that allows users to deposit money into the account: 1234567public class BankAccount { private double balance; public void deposit(double amount) { balance += amount; }} Now suppose we want to change the implementation of the BankAccount class to use a different data structure to store the balance, such as a BigDecimal instead of a double. If we had exposed the balance field directly, we would need to modify any code that accesses the balance field directly, which could be time-consuming and error-prone. However, because we used encapsulation and made the balance field private, we can change the implementation of the BankAccount class without affecting any external code that uses the class. All we need to do is modify the deposit method to work with the new data structure: 1234567public class BankAccount { private BigDecimal balance; public void deposit(BigDecimal amount) { balance = balance.add(amount); }} By encapsulating the internal state of the BankAccount class and exposing only a well-defined interface, we were able to make our code more flexible and maintainable. Without encapsulation, making changes to the internal implementation of a class could be much more difficult and error-prone. Type safetyIn Java, every variable, expression, and method call has a static type, also known as the compile-time type. The compile-time type is determined when the code is compiled and it determines which methods and properties are accessible for that variable, expression, or method call. The compile-time type is important information used by the compiler and IDEs (Integrated Development Environments) for type checking and code analysis. At runtime, Java also has a dynamic type, which is determined based on the actual object type. The dynamic type determines which methods and properties can be called on that object instance. To express the compile-time type of a variable, we use the syntax TypeName variableName;. For example, we can declare a variable of type int like this: int num;. To express the runtime type of an object, we use the instanceof operator, which checks whether an object is an instance of a particular class or an interface. For example, we can check whether an object obj is an instance of the String class like this: if (obj instanceof String) { ... }. Overall, understanding compile-time and runtime types is important for writing correct and efficient Java code, as well as for debugging and troubleshooting errors. Dynamic Method Selection12345678public static void main(String[] args) { VengefulSLList&lt;Integer&gt; vsl = new VengefulSLList&lt;Integer&gt;(9); SLList&lt;Integer&gt; sl = vsl; sl.addLast(50);//VengefulSLList doesn't override so uses SLList's sl.removeLast();//uses VengefulSLList's} Dynamic type Everything about Java[TOC] 输入输出流方式1.Scanner 类在 Java 中，Scanner 是一个类，用于读取用户的输入或者文件中的数据。Scanner 可以读取各种数据类型的输入，比如整数、浮点数、字符串等等。 以下是 Scanner 类的常用方法： next(): 读取输入的下一个字符串，以空格为分隔符。 nextInt(): 读取输入的下一个整数。 nextDouble(): 读取输入的下一个双精度浮点数。 nextLine(): 读取输入的下一行文本。 hasNext(): 判断输入中是否还有下一个输入项。 close(): 关闭 Scanner 对象。 下面是一个简单的例子，演示了如何使用 Scanner 从控制台读取用户输入的整数和字符串： 1234567891011121314151617import java.util.Scanner;public class ScannerExample { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); System.out.print(&quot;请输入一个整数: &quot;); int num = scanner.nextInt(); System.out.println(&quot;您输入的整数是: &quot; + num); System.out.print(&quot;请输入一个字符串: &quot;); String str = scanner.next(); System.out.println(&quot;您输入的字符串是: &quot; + str); scanner.close(); }} 这段代码中，我们首先创建了一个 Scanner 对象 scanner，用于读取用户的输入。然后，我们通过 nextInt() 方法读取了用户输入的整数，通过 next() 方法读取了用户输入的字符串，最后使用 close() 方法关闭了 Scanner 对象。 运行这段代码时，程序会提示用户输入一个整数和一个字符串，然后将用户输入的数据输出到控制台上。 如果用户输入的不是整数，程序将会抛出一个 InputMismatchException 异常。如果您想要避免这种异常，可以使用 hasNextInt() 方法先判断一下输入是否为整数，例如： 123456if (scanner.hasNextInt()) { int num = scanner.nextInt(); // ...} else { System.out.println(&quot;输入的不是整数&quot;);} 这样就可以避免因为用户输入错误而导致程序崩溃的问题。 2.io流中的BufferedReader首先采用 BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));初始化 类似于type[] dimensions = reader.readLine().split(“ “);可以分割地读取信息 使用BufferedReader 读取文件实录 1234567891011121314151617import java.io.*;public class ReadFile { public static void main(String[] args) { File file = new File(&quot;filename.txt&quot;); try { BufferedReader br = new BufferedReader(new FileReader(file)); String line; while ((line = br.readLine()) != null) { System.out.println(line); } br.close(); } catch (IOException e) { e.printStackTrace(); } }} Java 中的 BufferedReader 类是一个用于读取字符流的缓冲区，它继承自 Reader 类。下面是 BufferedReader 类中常用的方法： read()：读取单个字符并返回它的 Unicode 值，如果到达流的末尾，则返回 -1。 read(char[] cbuf, int off, int len)：读取字符到指定的字符数组 cbuf 中，从 off 索引位置开始，最多读取 len 个字符。 readLine()：读取一行文本并返回字符串，如果到达流的末尾，则返回 null。 skip(long n)：跳过 n 个字符。 mark(int readAheadLimit)：在当前位置设置标记，readAheadLimit 参数指定可以在不失去标记的情况下读取的字符数。 reset()：将流的位置重置为最近的标记。 close()：关闭流并释放与之关联的所有系统资源。 数据类型与类3.String流创建字符串最简单的方式如下: String str = “Runoob”; 在代码中遇到字符串常量时，这里的值是 “Runoob”，编译器会使用该值创建一个 String 对象。和其它对象一样，可以使用关键字和构造方法来创建 String 对象。 用构造函数创建字符串：String str2=new String(“Runoob”); 下面是一些常用的 String 方法及其作用： length()：返回字符串的长度。 12String str = &quot;Hello World&quot;;int length = str.length(); // length = 11 2.charAt(int index)：返回字符串中指定位置的字符。 12String str = &quot;Hello World&quot;;char ch = str.charAt(1); // ch = 'e' 3.substring(int beginIndex) 和 substring(int beginIndex, int endIndex)：分别返回从指定位置开始到字符串末尾的子串和指定范围内的子串。 123String str = &quot;Hello World&quot;;String sub1 = str.substring(6); // sub1 = &quot;World&quot;String sub2 = str.substring(0, 5); // sub2 = &quot;Hello&quot; 3.indexOf(int ch) 和 indexOf(String str)：分别返回指定字符或字符串第一次出现的位置，如果没有找到，则返回 -1。 123String str = &quot;Hello World&quot;;int index1 = str.indexOf('l'); // index1 = 2int index2 = str.indexOf(&quot;World&quot;); // index2 = 6 4.contains(String str)：返回字符串是否包含指定的子串。 12String str = &quot;Hello World&quot;;boolean contains = str.contains(&quot;World&quot;); // contains = true 5.equals(Object obj) 和 equalsIgnoreCase(String anotherString)：分别比较字符串是否相等和忽略大小写后是否相等。 1234String str1 = &quot;Hello World&quot;;String str2 = &quot;Hello world&quot;;boolean equals1 = str1.equals(str2); // equals1 = falseboolean equals2 = str1.equalsIgnoreCase(str2); // equals2 = true 6.toLowerCase() 和 toUpperCase()：分别返回字符串的小写形式和大写形式。 123String str = &quot;Hello World&quot;;String lower = str.toLowerCase(); // lower = &quot;hello world&quot;String upper = str.toUpperCase(); // upper = &quot;HELLO WORLD&quot; 7.trim()：返回去掉字符串首尾空格的字符串。 12String str = &quot; Hello World &quot;;String trimed = str.trim(); // trimed = &quot;Hello World&quot; 8.replace(char oldChar, char newChar) 和 replace(CharSequence target, CharSequence replacement)：分别返回用新字符或字符串替换所有旧字符或字符串后的新字符串。 123String str = &quot;Hello World&quot;;String replaced1 = str.replace('l', 'L'); // replaced1 = &quot;HeLLo WorLd&quot;String replaced2 = str.replace(&quot;World&quot;, &quot;Java&quot;); // replaced2 = &quot;Hello Java&quot; 9.startsWith(String prefix) 和 endsWith(String suffix)：分别返回字符串是否以指定的前缀或后缀开头/结尾。 123String str = &quot;Hello World&quot;;boolean startsWith = str.startsWith(&quot;Hello&quot;); // startsWith = trueboolean endsWith = str.endsWith(&quot;World&quot;); // endsWith = true 10.compareTo(String anotherString) 和 compareToIgnoreCase(String str)：分别按字典顺序比较字符串，返回两个字符串的差值。 123String str1 = &quot;Hello&quot;;String str2 = &quot;World&quot;;int result = str1.compareTo(str2); // result &lt; 0，因为 'H' 的 Unicode 值小于 'W' 11.matches(String regex)：返回字符串是否匹配指定的正则表达式。 12String str = &quot;Hello World&quot;;boolean matches = str.matches(&quot;Hello.*&quot;); // matches = true 12.format(String format, Object… args)：根据指定的格式化字符串和参数返回一个格式化后的新字符串。 1234String name = &quot;Alice&quot;;int age = 25;String formatted = String.format(&quot;My name is %s and I'm %d years old.&quot;, name, age);// formatted = &quot;My name is Alice and I'm 25 years old.&quot; 13.valueOf(Object obj)：将任意类型的数据转换为字符串。 12int num = 42;String str = String.valueOf(num); // str = &quot;42&quot; 14.getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)：将指定范围内的字符复制到目标字符数组中。 123String str = &quot;Hello World&quot;;char[] arr = new char[5];str.getChars(0, 5, arr, 0); // arr = ['H', 'e', 'l', 'l', 'o'] 15.isEmpty()：返回字符串是否为空，即长度为 0。 12String str = &quot;&quot;;boolean isEmpty = str.isEmpty(); // isEmpty = true 16.codePointAt(int index)：返回指定位置的 Unicode 码点。 12String str = &quot;Hello&quot;;int codePoint = str.codePointAt(1); // codePoint = 101，即 'e' 的 Unicode 码点 4.StringBuilder与StringBuffer类StringBuilder 和 StringBuffer 都是可变的字符序列，它们的作用类似于 String，但是它们允许在字符串中进行修改，而不会创建新的字符串对象。StringBuilder 和 StringBuffer 的主要区别在于线程安全性和性能。 StringBuilder 是线程不安全的，它的性能比 StringBuffer 更高。StringBuilder 主要提供了以下方法： append()：将指定的字符串或字符序列添加到当前 StringBuilder 对象末尾，并返回当前对象的引用。 12StringBuilder sb = new StringBuilder(&quot;Hello&quot;);sb.append(&quot; World&quot;); // sb = &quot;Hello World&quot; 2.insert()：将指定的字符串或字符序列插入到当前 StringBuilder 对象的指定位置，并返回当前对象的引用。 12StringBuilder sb = new StringBuilder(&quot;Hello&quot;);sb.insert(2, &quot;l&quot;); // sb = &quot;Hello&quot; 3.delete() 和 deleteCharAt()：分别删除指定范围内的字符和指定位置的字符，并返回当前对象的引用。 123StringBuilder sb = new StringBuilder(&quot;Hello World&quot;);sb.delete(5, 11); // sb = &quot;Hello&quot;sb.deleteCharAt(1); // sb = &quot;Hllo&quot; 4.replace()：将指定范围内的字符替换为指定的字符串或字符序列，并返回当前对象的引用。 12StringBuilder sb = new StringBuilder(&quot;Hello World&quot;);sb.replace(6, 11, &quot;Java&quot;); // sb = &quot;Hello Java&quot; 5.reverse()：将当前 StringBuilder 对象中的字符序列反转，并返回当前对象的引用。 12StringBuilder sb = new StringBuilder(&quot;Hello World&quot;);sb.reverse(); // sb = &quot;dlroW olleH&quot; 6.capacity()：返回当前 StringBuilder 对象的容量，即可用于存储字符的空间大小。 12StringBuilder sb = new StringBuilder(&quot;Hello World&quot;);int capacity = sb.capacity(); // capacity &gt; 11，因为 StringBuilder 会预留一定的空间 除了上述方法，StringBuilder 还继承了 Object 类的一些方法，例如 toString()、equals() 等。 和 StringBuilder 不同，StringBuffer 是线程安全的，因此在多线程环境中使用 StringBuffer 更为安全。它的方法和 StringBuilder 是类似的，但是 StringBuffer 的性能相对较低，因为它需要进行同步操作来保证线程安全。因此，如果在单线程环境中使用，建议使用 StringBuilder，而在多线程环境中使用，应该使用 StringBuffer。 Q: String可以用reverse颠倒吗？ A: 不可以，String 类是不可变的，因此它没有提供用于修改字符串的方法，包括 reverse() 方法。如果需要颠倒一个字符串，可以使用 StringBuilder 或 StringBuffer 的 reverse() 方法来实现。例如： 1234String str = &quot;Hello World&quot;;StringBuilder sb = new StringBuilder(str);sb.reverse();String reversed = sb.toString(); // reversed = &quot;dlroW olleH&quot; 在上面的代码中，先将字符串 “Hello World” 转换为 StringBuilder 对象 sb，然后调用 sb 的 reverse() 方法将其反转，最后将反转后的 StringBuilder 对象转换为字符串返回。 需要注意的是，由于 StringBuilder 和 StringBuffer 可以修改字符串，因此它们的 reverse() 方法会直接修改调用对象本身，而不是返回一个新的字符串。因此，在使用 reverse() 方法时应该注意是否需要保留原字符串。 当涉及到存储和操作多个相同类型的值时，Java 数组就是一个非常有用的数据结构。以下是一些和 Java 数组相关的内容和示例： 定义数组 在 Java 中，可以使用以下方式来定义数组： 12345678// 声明一个整型数组int[] numbers;// 声明并分配一个整型数组int[] numbers = new int[5];// 直接初始化一个整型数组int[] numbers = {1, 2, 3, 4, 5}; 在第一种情况下，只是声明了一个整型数组的变量，但是没有为它分配内存空间。在第二种情况下，声明并分配了一个长度为 5 的整型数组。在第三种情况下，直接初始化了一个长度为 5 的整型数组，并且赋予了初始值。 2.访问数组元素 可以使用下标访问数组中的元素，下标从 0 开始。例如，要访问数组中的第一个元素，可以使用 numbers[0]。 123int[] numbers = {1, 2, 3, 4, 5};int first = numbers[0]; // first = 1int third = numbers[2]; // third = 3 3.修改数组元素 可以使用下标来修改数组中的元素值。 12int[] numbers = {1, 2, 3, 4, 5};numbers[0] = 6; // numbers = {6, 2, 3, 4, 5} 4.遍历数组 可以使用 for 循环来遍历数组中的所有元素。 1234int[] numbers = {1, 2, 3, 4, 5};for (int i = 0; i &lt; numbers.length; i++) { System.out.println(numbers[i]);} 在上面的代码中，使用了 numbers.length 来获取数组的长度，从而遍历数组中的所有元素并输出。 5.多维数组 Java 中也支持多维数组。例如，可以使用以下方式定义一个二维数组： 12345int[][] matrix = { {1, 2, 3}, {4, 5, 6}, {7, 8, 9}}; 在上面的代码中，定义了一个 3x3 的二维数组，并初始化了它的元素。 6.数组拷贝 Java 中可以使用 Arrays 类提供的 copyOf() 和 copyOfRange() 方法来拷贝数组。例如，可以使用以下方式来拷贝一个数组： 12int[] source = {1, 2, 3, 4, 5};int[] target = Arrays.copyOf(source, source.length); 在上面的代码中，使用 Arrays.copyOf() 方法将 source 数组拷贝到 target 数组中。 这些是和 Java 数组相关的一些内容和示例，希望能够帮助你更好地理解和使用 Java 数组。 补充方法： public static int binarySearch(Object[] a, Object key) 用二分查找算法在给定数组中搜索给定值的对象(Byte,Int,double等)。数组在调用前必须排序好的。如果查找值包含在数组中，则返回搜索键的索引；否则返回 (-(插入点) - 1)。 public static void sort(Object[] a) 对指定对象数组根据其元素的自然顺序进行升序排列。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等） 数组等基本数据类型的内置方法数组（主要是整形）在Java中,数组类型(比如int[])有以下常用的内置方法: length:获取数组长度,比如int[] a = {1, 2, 3}; a.length == 3。 clone():拷贝数组,比如int[] b = a.clone();。 toString():转换为字符串,比如a.toString() == “[1, 2, 3]”。 equals():比较两个数组是否相等,需要元素也相等才会返回true。 hashCode():获取数组的哈希值,两个相等的数组hash值也相等。 sort():排序数组,比如int[] a = {3, 1, 2}; a.sort(); 之后 a == {1, 2, 3}。 binarySearch():二分查找,数组必须已排序,否则结果未定义。 copyOf():拷贝数组的一部分到新数组,比如int[] b = Arrays.copyOf(a, 2); 仅拷贝a中的前两个元素。 asList():将数组转换为List,比如List list = Arrays.asList(a);。 stream() / parallelStream():以顺序或并行流的方式处理数组,Java 8中新增。 fill():用指定值填充数组,比如a.fill(9);会使a变为{9, 9, 9}。 setAll():用指定函数设置所有元素的值,比如a.setAll(i -&gt; 2 * i); 会使a变为{0, 2, 4}。 除此之外,Java 8中还新增了一些方法来处理原始类型数组,比如: spliterator():返回数组的Spliterator forEach():遍历数组 reduce():聚合数组元素 count():统计数组元素出现次数 max()/min():找出最大/最小值所以,通过上述丰富的方法,我们可以非常便捷地操作和处理数组,不需要编写很多迭代和循环代码。这也是Java语言中方法的强大之处。 String类型与StringBuilder类型String的常用方法有: length():获取字符串长度。 charAt():获取指定索引的字符。 substring():截取字符串。 indexOf():查找字符或字符串首次出现的索引。 lastIndexOf():查找字符或字符串最后一次出现的索引。 startsWith():判断字符串是否以某个前缀开头。 endsWith():判断字符串是否以某个后缀结尾。 equals():判断两个字符串是否相等。 equalsIgnoreCase():判断两个字符串是否相等,忽略大小写。 replace():替换字符串中的字符或子字符串。 split():按照分隔符将字符串分割为子字符串数组。 toLowerCase():将字符串转为小写。 toUpperCase():将字符串转为大写。 hashCode():获取字符串的哈希值。 compareTo():比较两字符串的顺序,返回负数、0或正数。 StringBuilder的常用方法有: append():追加字符串或数据到StringBuilder中。 insert():在指定索引插入字符串或数据。 delete():删除字符序列。 reverse():反转StringBuilder中的字符序列。 capacity():获取StringBuilder的容量。 ensureCapacity():确保StringBuilder具有最小容量。 length():获取字符序列长度。 charAt():获取指定索引的字符。 setCharAt():设置指定索引的字符。 toString():将StringBuilder转换为String。相比于String,StringBuilder更加适合进行字符串的构建和修改。因为StringBuilder的对象可以被多次修改,而String的对象一旦创建就不可变。所以,当我们需要频繁修改字符串内容时,StringBuilder会更加高效。等字符串构建完成后,可以使用toString()方法转换为String使用。 String s = &quot;Hello World&quot;; s.length(); // 11 s.charAt(6); // 'W' s.substring(6, 11); // &quot;World&quot; s.indexOf(&quot;or&quot;); // 7 s.lastIndexOf(&quot;l&quot;); // 10 s.startsWith(&quot;He&quot;); // true s.endsWith(&quot;ld&quot;); // true s.equals(&quot;Hello World&quot;); // true s.equalsIgnoreCase(&quot;hello world&quot;); // true s.replace(&quot;World&quot;, &quot;Java&quot;); // &quot;Hello Java&quot; s.split(&quot; &quot;); // [&quot;Hello&quot;, &quot;World&quot;] s.toLowerCase(); // &quot;hello world&quot; s.toUpperCase(); // &quot;HELLO WORLD&quot; 123456789101112131415StringBuilder示例:```javaStringBuilder sb = new StringBuilder(&quot;Hello&quot;);sb.append(&quot; World&quot;); // sb = &quot;Hello World&quot;sb.insert(6, &quot;Java&quot;); // sb = &quot;Hello JavaWorld&quot; sb.delete(6, 11); // sb = &quot;Hello Java&quot;sb.reverse(); // sb = &quot;avaJ olleH&quot;sb.capacity(); // 16sb.ensureCapacity(20); // 容量变为20sb.length(); // 10sb.charAt(0); // 'a'sb.setCharAt(0, 'H'); // sb = &quot;HavaJ olleH&quot;String s = sb.toString(); // s = &quot;HavaJ olleH&quot; Java.util详解java.util包中包含了很多常用的数据类型和方法,主要有: List接口及其实现类:ArrayList、LinkedList、Vector等,用于存储列表数据。 Set接口及其实现类:HashSet、TreeSet等,用于存储无序不重复的数据。 Map接口及其实现类:HashMap、TreeMap、Hashtable等,用于存储键值对数据。 Iterator接口:用于遍历集合元素,所有集合类都有自己的Iterator实现。 Comparator和Comparable接口:用于排序,Comparator用于定制排序,Comparable表示可比较的意思。 Collections工具类:提供了对集合进行操作的静态方法,如排序、查找、替换等。 Arrays工具类:提供了数组相关的工具方法,如排序、查找、填充等。 Date、Calendar、SimpleDateFormat:用于日期和时间的处理。 Random:用于生成随机数。 StringTokenizer:用于字符串切分。 BitSet:按位存储数据,适用于大规模数据的压缩。 Queue接口及其实现类:用于队列操作,如LinkedList可以当做队列使用。 Stack:基于Vector实现,用于栈操作。 Properties:键值对,可以保存到流中或加载从流中。 接下来我们详细分析这些类 1/6 Collection接口是集合框架层次结构的根接口。 Java没有提供直接实现Collection接口，但是像提供其子接口List，Set和Queue的实现。 如前所述，Collection接口包括由Java类实现的子接口。 Collection接口的所有方法也都存在于其子接口中。 下面三种接口是Collection接口的子接口： 1、List 接口List接口是一个有序的集合，它允许我们像数组一样添加和删除元素。 2、Set 接口Set接口允许我们将元素存储在不同的集合中，类似于数学中的集合。它不能有重复的元素。 3、Queue 接口当我们要以先进先出的方式存储和访问元素时，可以使用Queue接口。 实现List的类由于List是接口，因此无法从中创建对象。 为了使用List接口的功能，我们可以使用以下类： 数组列表（ArrayList类） 链表（LinkedList类） 向量（vector类） 堆栈（Stack类） 1.ArrayListArrayList 类位于 java.util 包中，使用前需要引入它，语法格式如下： 123import java.util.ArrayList; // 引入 ArrayList 类ArrayList&lt;E&gt; objectName =new ArrayList&lt;&gt;(); // 初始化 E: 泛型数据类型，用于设置 objectName 的数据类型，只能为引用数据类型。(如String/Integer) objectName: 对象名。 ArrayList 是一个数组队列，提供了相关的添加、删除、修改、遍历等功能。 深入理解JVM .class File structureThe ClassFile StructureA class file consists of a single ClassFile structure: 123456789101112131415161718ClassFile { u4 magic; u2 minor_version; u2 major_version; u2 constant_pool_count; cp_info constant_pool[constant_pool_count-1]; u2 access_flags; u2 this_class; u2 super_class; u2 interfaces_count; u2 interfaces[interfaces_count]; u2 fields_count; field_info fields[fields_count]; u2 methods_count; method_info methods[methods_count]; u2 attributes_count; attribute_info attributes[attributes_count];} • ⼀组以8位字节为基础单位的⼆进制流 • 魔数 ​ • 0xCAFEBABE • 版本号 • 常量池 ​ • 字⾯量 ​ • 符号引⽤ • 访问标志 • 类索引、⽗类索引与接⼝索引集合 • 字段表集合 • ⽅法表集合 • 属性表集合 （代码的实现作为⼀个属性值） 《Java虚拟机原理图解》 1.1、class文件基本组织结构_亦山的博客-CSDN博客 字段信息数据指的是类中定义的字段，包括静态字段和实例字段。这些字段可以是基本数据类型（如int、float等），也可以是引用类型（如对象、数组等），它们在类的生命周期内保存着不同的数据。 每个字段在class文件中都会有一条字段表（Field Info）的数据结构来描述它的属性，包括字段名、访问修饰符、字段类型、常量值等信息。这些信息可以被JVM用来验证类的正确性，并在运行时动态地访问或修改字段的值。 属性信息（Attribute Info）是指一个类、字段或方法的附加信息。 类属性信息包括常量池、父类、接口表、字段表、方法表等。 字段属性信息描述了字段的一些附加信息，如字段的访问标志、常量值等。 方法属性信息可以描述方法的一些附加信息，如方法的访问标志、局部变量表、操作数栈、异常表、代码等。 jvm运行时数据区 虚拟机栈是什么？ 栈帧是什么？ 在运行时，常量池存放编译器生成的各种字面量与符号引用 在Java程序编译为字节码文件时，会将程序中使用的字符串、数字、符号引用等常量都存储在一个被称为常量池（Constant Pool）的表中。常量池是JVM运行时数据区的一部分，用于存储字面量和符号引用，是Java虚拟机实现语言级别不可变性和动态绑定的关键数据结构之一。常量池的作用是为了提高字节码的执行效率，避免了反复解析和计算常量值的过程，同时也为Java的反射机制、动态代理、字符串常量池等提供了基础。 下面是一个简单的Java代码示例： 123456789public class ConstantPoolDemo { public static void main(String[] args) { String s1 = &quot;Hello&quot;; String s2 = &quot;World&quot;; String s3 = s1 + s2; String s4 = &quot;HelloWorld&quot;; System.out.println(s3 == s4); // true }} 在编译时，常量池会存储字符串”Hello”和”World”以及”HelloWorld”的字面量，存储在常量池中的字符串会被JVM优化为常量，以便在程序运行时快速访问。在上述代码中，s1和s2是两个字符串变量，s3是由s1和s2拼接而成的新字符串，s4是一个字符串常量。在执行println语句时，由于s3和s4的值都为”HelloWorld”，因此它们在常量池中的引用是相同的，所以s3 == s4的结果为true。 除了字符串常量外，常量池还可以存储其他类型的常量，如数字常量、类和接口的符号引用等。在JVM中，常量池是类加载过程中的一个重要组成部分，它的内容在类加载时被加载并存储在方法区（Metaspace）中。在程序运行时，当需要引用常量池中的某个常量时，JVM会直接从常量池中获取该常量的值，而不是重新计算或解析该常量。 虚拟机运行的总体路线: In programming languages like C and C++, the code is first compiled into platform-specific machine code. These languages are called compiled languages. On the other hand, in languages like JavaScript and Python, the computer executes the instructions directly without having to compile them. These languages are called interpreted languages. Java uses a combination of both techniques. Java code is first compiled into byte code to generate a class file. This class file is then interpreted by the Java Virtual Machine for the underlying platform. The same class file can be executed on any version of JVM running on any platform and operating system. Three distinct components: Class Loader Runtime Memory/Data Area Execution Engine 1.类加载机制类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个 java.lang.Class对象，用来封装类在方法区内的数据结构。类的加载的最终产品是位于堆区中的 Class对象， Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。 字节码专题运算指令 • 算术指令⽤于对两个操作数栈上的值进⾏某种特定运算，并 把结果重新存⼊到操作栈顶。 • 1)加法指令:iadd,ladd,fadd,dadd • 2)减法指令:isub,lsub,fsub,dsub • 3)乘法指令:imul,lmul,fmul,dmul • 4)除法指令:idiv,ldiv,fdiv,ddiv • 5)求余指令:irem,lrem,frem,drem • 6)取反指令:ineg,leng,fneg,dneg • 7)位移指令:ishl,ishr,iushr,lshl,lshr,lushr • 8)按位或指令:ior,lor • 9)按位与指令:iand,land • 10)按位异或指令:ixor,lxor • 11)局部变量⾃增指令:iinc • 12)⽐较指令:dcmpg,dcmpl,fcmpg,fcmpl,lcmp • Java虚拟机没有明确规定整型数据溢出的情况，但规定了处 理整型数据时，只有除法和求余指令出现除数为0时会导致 虚拟机抛出异常。 • Java虚拟机要求在浮点数运算的时候，所有结果否必须舍⼊ 到适当的精度，如果有两种可表示的形式与该值⼀样，会优 先选择最低有效位为零的。称之为最接近数舍⼊模式。 • 浮点数向整数转换的时候，Java虚拟机使⽤IEEE 754标准中 的向零舍⼊模式，这种模式舍⼊的结果会导致数字被截断， 所有⼩数部分的有效字节会被丢掉。 • 如同操作⼀个普通数据结构中的堆栈那样，Java 虚拟机提供了⼀些⽤ 于直接操作操作数栈的指令，包括： • 1）将操作数栈的栈顶⼀个或两个元素出栈：pop、pop2 • 2）复制栈顶⼀个或两个数值并将复制值或双份的复制值重新压 ⼊栈顶：dup、dup2、dup_x1、dup2_x1、dup_x2、dup2_x2。 • 3）将栈最顶端的两个数值互换：swap OOP Part由于结构化编程具有不易阅读、不易变更、难以添加需求的缺点，因此采用面向对象编程的方式合并数据和行为职责，类就是这种职责的抽象，对象则是职责的具体实现。 对象的定义每个对象都保存着描述当前特征的信息，对象状态的改变必须通过调用方法实现，对象的状态不能完全描述一个对象，每个对象都有唯一的身份，每个对象的标识与状态基本不同。 类这个术语用来表述相同事物的集合，以概要的方式描述了相同事物中的所有元素，但是允许每一个元素在非本质特征上发生变化。 一旦定义了一个类，就可以接着得到这个类的对象或者实例，实例变量的值由类的每个实例提供。 方法与封装既要注意属性的覆盖，也要注意统一；其次，要注意封装的完备性，不能出现一个只能加水不能倒水的杯子 职责 数据职责 表征对象的本质特征 行为计算所需要的数据 行为职责 表征对象的本质行为 拥有数据所应该体现的行为 Static Method 和 Final Method在Java中，static和final是两个不同的关键字，用于不同的目的。 static关键字用于创建静态成员，这意味着它们与类本身相关，而不是与类的实例相关。静态成员包括静态变量和静态方法。静态变量是被所有类的实例共享的变量，而静态方法是不依赖于类的实例而被调用的方法。 例如，下面的代码演示了如何声明和使用静态变量和静态方法： 1234567891011public class MyClass { static int myStaticVar = 42; static void myStaticMethod() { System.out.println(&quot;This is a static method.&quot;); }}// usageint value = MyClass.myStaticVar;MyClass.myStaticMethod(); final关键字用于创建常量，这意味着它们不能被更改。final变量必须在声明时初始化，并且不能被再次赋值。final方法表示它们不能被子类重写。 例如，下面的代码演示了如何声明和使用final变量和final方法： 123456789101112public class MyClass { final int myFinalVar = 42; final void myFinalMethod() { System.out.println(&quot;This is a final method.&quot;); }}// usageMyClass obj = new MyClass();int value = obj.myFinalVar;obj.myFinalMethod(); 总的来说，static和final都用于创建不同类型的成员，static用于创建静态成员，final用于创建常量和不可重写的方法。","link":"/2023/08/02/java-notes/"}],"tags":[{"name":"algorithm","slug":"algorithm","link":"/tags/algorithm/"},{"name":"java","slug":"java","link":"/tags/java/"}],"categories":[],"pages":[]}